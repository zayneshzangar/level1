package main

import "fmt"

type Printer struct{}

func (p *Printer) PrintMessage(msg string) {
	fmt.Println("Printed: " + msg)
}

type Logger interface {
	Log(msg string)
}

type LoggerAdapter struct {
	printer *Printer
}

func NewLoggerAdapter(printer *Printer) *LoggerAdapter {
	return &LoggerAdapter{printer: printer}
}

func (a *LoggerAdapter) Log(msg string) {
	a.printer.PrintMessage(msg)
}

func main() {
	printer := &Printer{}
	var logger Logger = NewLoggerAdapter(printer)
	logger.Log("Привет!")
}

/*
Паттерн "Адаптер" используется, когда нужно соединить две 
несовместимые части кода или систем, как переходник для 
старого телевизора с новым розеткой.

Где применяют:
1. Интеграция старого (legacy) кода. Старая функция печатает 
   сообщения, а новая хочет логировать их по-другому
2. Работа с сторонними библиотеками. Ты используешь библиотеку 
   с интерфейсом, который не совпадает с твоим кодом. Адаптер 
   помогает подогнать её под твои нужды
3. Единый интерфейс для разных систем (БД)
4. Когда нужно быстро подключить что-то новое. Если у тебя новый 
   клиент, который ждёт определённый способ работы, а старый код 
   работает иначе, адаптер решает проблему без переписывания старого

Плюсы паттерна:
1. Не трогаем старый код
2. Гибкость. Легко подключить новые системы или заменить старые
3. Упрощение интеграции. Не нужно переписывать сложные библиотеки — 
   адаптер делает мост между ними и твоим кодом
4. Соблюдение принципа Open/Closed


Минусы паттерна:
1. Дополнительный слой. Адаптер добавляет ещё один уровень кода
2. Может стать запутанным. Если адаптеров слишком много, код становится 
   сложнее для понимания, особенно для новичков
3. Ограниченная универсальность. Адаптер решает только проблему 
   совместимости интерфейсов, но не помогает, если старый код имеет 
   ошибки или неэффективен
4. Зависимость от старого кода


*/