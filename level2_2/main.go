package main

import "fmt"

func test() (x int) {
  defer func() {
    x++
  }()
  x = 1
  return
}

func anotherTest() int {
  var x int
  defer func() {
    x++
  }()
  x = 1
  return x
}

func main() {
  fmt.Println(test())
  fmt.Println(anotherTest())
}

/*
ВЫВОД:
2
1


Порядок выполнения test:
1. x изначально равно 0 (из-за именованной возвращаемой переменной).
2. defer func() { x++ }() регистрируется и будет выполнен позже.
3. x = 1 присваивает значение 1 переменной x.
4. return без аргументов возвращает текущее значение именованной переменной x. 
   Однако перед этим Go выполняет все отложенные (defer) функции.
5. defer увеличивает x на 1 (с 1 до 2), и именно это обновлённое значение возвращается.

Почему перед return?: В случае именованной возвращаемой переменной x, 
defer имеет доступ к этой переменной на момент её возврата. Go 
сохраняет значение x до выполнения defer, а затем использует 
обновлённое значение после всех defer. Это поведение связано 
с тем, что именованная переменная является частью состояния функции, 
и defer может её модифицировать до финального возврата.


Порядок выполнения anotherTest:

1. var x int объявляет локальную переменную x, которая инициализируется нулем (0).
2. defer func() { x++ }() регистрируется для выполнения позже.
3. x = 1 присваивает значение 1 переменной x.
4. return x возвращает текущее значение x (1) и завершает выполнение тела функции.
5. После возврата значения defer выполняется и увеличивает x на 1 (до 2), 
   но это уже не влияет на результат, так как значение для возврата было 
   зафиксировано на этапе return x.


Почему после return?: Здесь x — локальная переменная, а не именованная 
возвращаемая. Когда return x выполняется, значение x копируется и возвращается 
вызывающей функции. После этого defer выполняется, но изменяет только 
локальную копию x, которая уже не участвует в возврате.
*/